# 设备上下文架构设计文档

## 1. 架构概述

基于用户需求，项目从线程模式转向进程模式，采用以下架构：

### 1.1 核心原则
- **主进程**：负责设备进程管理、前端交互、状态汇总，**不包含调度引擎**
- **设备进程**：每个设备进程有独立的调度引擎，**同时只能运行一个脚本**
- **进程通信**：通过IPC（进程间通信）协调主进程与设备进程

### 1.2 最大并发任务数说明
- 最大并发任务数 = 最大设备数量
- 因为每个设备同时只能运行一个脚本
- 例如：4个设备 = 最多同时执行4个脚本

## 2. 架构组件

### 2.1 主进程 (Main Process)

**文件**：`src-tauri/src/domain/manager/main_process_manager.rs`

**职责**：
- 管理设备进程的启动/停止
- 接收前端的脚本状态切换请求
- 通过IPC向设备进程发送指令
- 汇总各设备状态并展示给前端
- 全局脚本注册表管理
- 脚本到设备的分配管理

**关键结构**：
```rust
pub struct MainProcessManager {
    devices: HashMap<String, DeviceContext>,           // 设备上下文
    script_device_mapping: HashMap<ScriptId, String>,  // 脚本设备映射
    global_scripts: HashMap<ScriptId, Script>,         // 全局脚本注册表
    device_channels: HashMap<String, mpsc::Sender>,    // 设备通信通道
}
```

### 2.2 设备进程 (Device Process)

**文件**：`src-tauri/src/domain/manager/device_process_manager.rs`

**职责**：
- 运行独立的调度引擎
- 管理分配给该设备的脚本列表
- 根据时间段调度执行脚本
- 强制单脚本执行约束
- 通过IPC与主进程通信状态

**关键结构**：
```rust
pub struct DeviceProcessManager {
    device_id: String,
    scheduler: ScriptScheduler,                         // 独立调度引擎
    device_scripts: HashMap<ScriptId, Script>,         // 设备脚本列表
    current_running_script: Option<ScriptId>,          // 当前运行脚本(单一)
}
```

### 2.3 脚本结构体

**文件**：`src-tauri/src/domain/entities/devices/script.rs`

**核心特性**：
- 支持时间段调度 (`ScriptScheduleConfig`)
- 执行优先级管理 (`ScriptPriority`)
- 状态跟踪 (`ScriptStatus`)
- 资源需求估算 (`ScriptResourceRequirements`)
- 执行统计 (`ScriptExecutionStats`)

### 2.4 调度引擎

**文件**：`src-tauri/src/domain/entities/scheduler/`

**组件**：
- `script_scheduler.rs` - 脚本调度器
- `task_queue.rs` - 任务队列管理
- `scheduler_state.rs` - 调度器状态管理

**特性**：
- 基于时间段的脚本调度
- 优先级队列管理
- 失败重试机制
- 空闲检测

### 2.5 设备上下文

**文件**：`src-tauri/src/domain/entities/devices/device_context.rs`

**重新设计的特性**：
- 移除每设备独立调度器（调度器现在在设备进程中）
- 支持进程管理和状态跟踪
- 设备性能配置和统计
- 脚本列表管理

## 3. 进程间通信 (IPC)

### 3.1 通信协议

**主进程 → 设备进程指令**：
```rust
pub enum DeviceCommand {
    StartScript { script_id: ScriptId },
    StopScript { script_id: ScriptId },
    PauseScript { script_id: ScriptId },
    ResumeScript { script_id: ScriptId },
    AddScript { script: Script },
    RemoveScript { script_id: ScriptId },
    GetStatus,
    Shutdown,
}
```

**设备进程 → 主进程报告**：
```rust
pub enum DeviceStatusReport {
    ScriptStatusUpdate { script_id: ScriptId, status: ScriptStatus },
    DeviceStatusUpdate { status: DeviceStatus },
    ScriptExecutionResult { script_id: ScriptId, success: bool, execution_time_ms: u64 },
    DeviceStats { cpu_usage: f32, memory_usage: u64, running_script: Option<ScriptId> },
    Error { message: String },
    Heartbeat,
}
```

### 3.2 通信机制

1. **指令通道**：主进程通过 `mpsc::channel` 向设备进程发送指令
2. **状态报告**：设备进程通过另一个 `mpsc::channel` 向主进程报告状态
3. **心跳机制**：设备进程定期发送心跳确保连接
4. **异步处理**：所有通信均为异步，避免阻塞

## 4. 工作流程

### 4.1 脚本执行流程

1. **前端请求**：用户在主界面点击启动脚本
2. **主进程处理**：
   - 检查脚本是否已分配到设备
   - 检查目标设备状态
   - 验证设备是否空闲（单脚本约束）
3. **发送指令**：主进程向设备进程发送 `StartScript` 指令
4. **设备进程执行**：
   - 设备进程的调度引擎处理启动请求
   - 检查设备当前状态（确保没有其他脚本在运行）
   - 启动脚本执行
   - 更新 `current_running_script`
5. **状态同步**：设备进程向主进程报告脚本状态变化
6. **前端更新**：主进程将状态更新推送到前端界面

### 4.2 调度引擎工作流程

1. **脚本注册**：脚本被添加到设备的调度引擎
2. **时间检查**：调度引擎按配置的检查间隔验证执行时间
3. **优先级排序**：符合时间条件的脚本按优先级排队
4. **单脚本约束**：确保设备同时只运行一个脚本
5. **执行监控**：跟踪脚本执行状态和性能
6. **状态报告**：向主进程报告执行结果

## 5. 配置和性能

### 5.1 性能配置

```rust
pub struct Performance {
    pub cores_per_device: u32,    // 每设备分配核心数
    pub max_devices: usize,       // 最大设备数
}
```

### 5.2 调度器配置

```rust
pub struct SchedulerConfig {
    pub max_concurrent_tasks: usize,           // = 1 (单设备单脚本)
    pub check_interval_seconds: u64,           // 调度检查间隔
    pub default_task_timeout_seconds: u64,     // 默认任务超时
    pub enable_auto_retry: bool,               // 启用自动重试
    pub default_retry_count: u32,              // 默认重试次数
}
```

## 6. 关键约束和特性

### 6.1 单脚本约束
- **强制约束**：每个设备同时只能运行一个脚本
- **实现方式**：`current_running_script: Option<ScriptId>`
- **检查时机**：启动脚本前强制检查
- **冲突处理**：提供替换当前脚本的选项

### 6.2 进程隔离
- **设备独立**：每个设备运行在独立进程中
- **故障隔离**：单个设备崩溃不影响其他设备
- **资源隔离**：CPU核心和内存按设备分配
- **调度独立**：每个设备有独立的调度引擎

### 6.3 状态同步
- **实时同步**：脚本状态变化实时同步到主进程
- **心跳监控**：设备进程定期发送心跳
- **错误处理**：通信失败时的重试和降级策略
- **状态一致性**：确保主进程和设备进程状态一致

## 7. 文件结构

```
src-tauri/src/
├── domain/
│   ├── entities/
│   │   ├── devices/
│   │   │   ├── script.rs              # 脚本结构体
│   │   │   └── device_context.rs      # 设备上下文
│   │   └── scheduler/
│   │       ├── script_scheduler.rs    # 脚本调度器
│   │       ├── task_queue.rs         # 任务队列
│   │       └── scheduler_state.rs    # 调度器状态
│   └── manager/
│       ├── main_process_manager.rs    # 主进程管理器
│       └── device_process_manager.rs  # 设备进程管理器
└── infrastructure/
    └── performance.rs                 # 进程管理器
```

## 8. 总结

这个架构设计正确地实现了用户需求：

1. ✅ **调度引擎在设备进程中**：每个设备进程有独立的调度引擎
2. ✅ **单设备单脚本**：强制约束同时只能运行一个脚本
3. ✅ **主进程协调**：主进程负责管理和前端交互，不包含调度逻辑
4. ✅ **进程隔离**：设备之间完全隔离，故障不相互影响
5. ✅ **状态同步**：主界面切换脚本状态能正确反映到设备进程
6. ✅ **时间段调度**：支持基于时间段的脚本自动调度
7. ✅ **IPC通信**：清晰的进程间通信机制

此架构符合现代微服务设计原则，具有良好的可扩展性、可维护性和故障隔离能力。
