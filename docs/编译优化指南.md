# Tauri Rust 编译速度优化指南

## 🎯 问题诊断

Tauri 项目编译慢的主要原因：
1. ⏰ **Rust 编译本身较慢**（类型检查、生命周期分析、LLVM 优化）
2. 📦 **依赖包多**（第一次编译需要编译所有依赖）
3. 🔗 **链接时间长**（特别是 Windows 上的 `link.exe`）
4. 🖼️ **重型依赖**（如 `ort`、`image`、`sqlx` 等）

---

## ✅ 已实施的优化方案

### 1. **编译缓存 - sccache** ⚡
```toml
rustc-wrapper = "D:\\Database\\Rust\\cargo\\bin\\sccache.exe"
```
**效果**：
- ✨ 首次编译：无加速
- 🚀 重复编译：**5-10 倍速度提升**
- 💡 原理：缓存编译结果，相同代码不重复编译

**验证是否生效**：
```powershell
# 查看缓存统计
sccache --show-stats

# 清空缓存（如需重新测试）
sccache --zero-stats
```

### 2. **优化级别调整** 📊
```toml
[profile.dev]
opt-level = 1             # 从 3 降到 1
```
**效果**：
- 编译时间减少 **30-50%**
- 运行性能略降（开发环境可接受）

**对比**：
| opt-level | 编译速度 | 运行速度 | 适用场景 |
|-----------|---------|---------|---------|
| 0 | 最快 | 最慢 | 快速迭代 |
| 1 | 快 | 较快 | **推荐开发** |
| 2 | 中 | 快 | 预发布测试 |
| 3 | 慢 | 最快 | 生产发布 |

### 3. **并行编译优化** 🔢
```toml
codegen-units = 256
```
**效果**：
- 充分利用多核 CPU
- 编译时间减少 **20-40%**（取决于 CPU 核心数）

**说明**：
- 数值越大：编译越快，但生成的代码可能略慢
- 开发环境建议 256，生产环境建议 1

### 4. **依赖优化编译** 📦
```toml
[profile.dev.package."*"]
opt-level = 3
```
**原理**：
- 你的代码：opt-level = 1（快速编译）
- 依赖包：opt-level = 3（快速运行）
- **最佳平衡**：编译快 + 运行快

---

## 🚀 进阶优化技巧

### 技巧 1：减少特性依赖
在 `Cargo.toml` 中，只启用需要的 features：

**❌ 不好的做法**：
```toml
tokio = { version = "1", features = ["full"] }
```

**✅ 推荐做法**：
```toml
tokio = { version = "1", features = ["rt-multi-thread", "macros", "sync", "time"] }
```

**你的项目检查**：
```toml
# 当前配置
tokio = { version = "1", features = ["full"] }  # ⚠️ 建议优化
ort = { version = "2.0.0-rc.10", features = ["directml", "cuda"] }  # ⚠️ 如果不用 CUDA，可移除
```

### 技巧 2：条件编译
对于开发环境不需要的功能，使用条件编译：

```toml
[dependencies]
# 仅在 release 模式启用 CUDA
ort = { version = "2.0.0-rc.10", features = ["directml"] }

[dev-dependencies]
ort = { version = "2.0.0-rc.10", features = ["directml", "cuda"] }
```

### 技巧 3：使用 mold 链接器（Linux）或 lld（Windows）
**Windows 优化**：
```toml
# .cargo/config.toml
[target.x86_64-pc-windows-msvc]
linker = "rust-lld"
```
**效果**：链接时间减少 **30-50%**

⚠️ **注意**：需要先安装 lld
```powershell
rustup component add llvm-tools-preview
```

### 技巧 4：智能 watch 模式
使用 `cargo-watch` 进行智能热重载：

```powershell
# 安装
cargo install cargo-watch

# 使用
cargo watch -x "build --no-default-features"
```

### 技巧 5：部分编译
如果只修改了前端代码，跳过 Rust 编译：

```powershell
# 仅开发前端（不编译 Rust）
pnpm run dev:frontend

# 完整开发（包含 Rust）
pnpm run tauri dev
```

在 `package.json` 中添加：
```json
{
  "scripts": {
    "dev:frontend": "vite",
    "dev": "tauri dev"
  }
}
```

---

## 🎓 关于模块化的深入解答

### Q: 将代码拆分成多个 crate 能加速编译吗？

**短答案**：对于中小型项目（< 50,000 行），**不推荐**。

**详细分析**：

#### ✅ **模块化的优点**
1. **增量编译更精细**
   - 修改子模块 A，不需要重新编译子模块 B
   
2. **并行编译不同 crate**
   - Cargo 可以同时编译多个独立的 crate

3. **编译缓存更有效**
   - 未修改的 crate 完全跳过编译

#### ❌ **模块化的缺点**
1. **首次编译更慢**
   - 每个 crate 都有独立的编译上下文
   - 需要生成多个 .rlib/.so 文件
   
2. **跨 crate 调用开销**
   - 需要导出公共接口（`pub`）
   - 编译器优化受限（跨 crate 内联困难）
   
3. **维护成本增加**
   - 需要管理多个 `Cargo.toml`
   - 依赖关系复杂化

#### 📊 **性能对比测试**

假设项目有 30,000 行代码，修改 100 行：

| 架构 | 首次编译 | 增量编译 | 复杂度 |
|------|---------|---------|--------|
| 单 crate | 60s | 5s | 低 |
| 5 个 crate | 75s | 3s | 中 |
| 10 个 crate | 90s | 2s | 高 |

**结论**：仅在频繁修改且项目巨大（> 100k 行）时，模块化才值得。

---

## 🔥 实战建议

### 当前项目优化路线图

#### 阶段 1：立即见效（已完成 ✅）
- [x] 启用 sccache 缓存
- [x] opt-level = 1
- [x] codegen-units = 256
- [x] 依赖优化编译

**预期提升**：重复编译速度提升 **5-8 倍**

#### 阶段 2：深度优化（可选）
- [ ] 减少 tokio features
- [ ] 移除不需要的 ort features（如 cuda）
- [ ] 使用 lld 链接器

**预期提升**：首次编译速度提升 **20-30%**

#### 阶段 3：工作流优化
- [ ] 前后端分离开发
- [ ] 使用 cargo-watch 热重载
- [ ] 设置 CI/CD 构建缓存

**预期提升**：开发体验显著改善

---

## 📈 性能监控

### 1. 查看编译时间分布
```powershell
cargo build --timings
# 会生成一个 HTML 报告，显示每个 crate 的编译时间
```

### 2. 查看 sccache 效率
```powershell
sccache --show-stats
```

### 3. 分析依赖树
```powershell
cargo tree --depth 1
# 查看哪些依赖最重
```

---

## ❓ 常见问题

### Q1: 为什么不能用 cranelift？
**A**: cranelift 与某些 FFI 包不兼容，特别是：
- `aws-lc-rs`（TLS 加密库）
- `ring`（密码学库）
- 其他包含 C/C++ FFI 的库

### Q2: opt-level = 1 会影响性能吗？
**A**: 
- 编译速度：提升 30-50%
- 运行速度：降低 10-20%
- **开发环境完全可接受**

### Q3: 依赖优化编译会影响调试吗？
**A**: 不会，只优化依赖包，你的代码仍保持 opt-level = 1，调试体验不变。

### Q4: sccache 缓存会占用多少空间？
**A**: 
- 默认上限：10 GB
- 可配置：`SCCACHE_CACHE_SIZE=20G`
- 清理：`sccache --stop-server`（自动清理过期缓存）

---

## 🎯 最终建议

**对于您的项目**：

1. ✅ **保持当前配置**（sccache + opt-level 1 + codegen-units 256）
2. ✅ **不需要模块化**（项目规模不够大）
3. ⚠️ **可选优化**：精简 tokio 和 ort 的 features
4. 💡 **工作流改进**：前后端分离开发

**预期效果**：
- 首次编译：60-90 秒（无法避免）
- 增量编译（小改动）：**3-5 秒** ⚡
- 增量编译（大改动）：**10-15 秒** ⚡

这已经是在不使用 cranelift 的情况下，能达到的最优配置了！

---

## 📚 参考资源

- [Cargo Book - Profiles](https://doc.rust-lang.org/cargo/reference/profiles.html)
- [sccache Documentation](https://github.com/mozilla/sccache)
- [Rust Compile Times](https://endler.dev/2020/rust-compile-times/)
